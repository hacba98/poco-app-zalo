/**
 * Implement interface generated by thrift compiler for server stub code
 */

#include "handler.h"

using namespace std;
using namespace kyotocabinet;
using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;

using apache::thrift::to_string;

FriendServicesHandler::FriendServicesHandler(){
	// -- Setup serialize process
	boost::shared_ptr<TMemoryBuffer> buffer(new TMemoryBuffer());
	boost::shared_ptr<TProtocol> iprot(new TBinaryProtocol(buffer));
	boost::shared_ptr<TProtocol> oprot(new TBinaryProtocol(buffer));	
	
	this->buffer_ = buffer;
	this->iprot_ = iprot;
	this->oprot_ = oprot;
	
	this->counterPath = "./storage/counter.kch";
	this->dbPath = "./storage/user_data.kch";
	this->friendLstPath = "./storage/friend.kch";
	this->pendingPath = "./storage/pending.kch";
	
	// -- Setup DB part
//	try {
//		if (!db.open(this->counterPath, HashDB::OREADER)){ // First time run server
//			cout << "Hello?" << endl;
//			db.close();
//			db.open(this->counterPath, HashDB::OWRITER | HashDB::OCREATE);
//			db.set("user_counter", "0");
//			db.close();
//		}
//	} catch (string e){
//		cerr << e << endl;
//	}
}

int32_t FriendServicesHandler::CreateUser(const InputProfileData& profile){
	if (profile.__isset.name == false or profile.__isset.isMale == false or profile.__isset.birthDate == false or profile.__isset.phoneNumber == false){
		return -1; // TODO - Return error code
	}
	using ::apache::thrift::to_string;
	
	string counter_value = "0";
	// get id count from DB
	try {
		// open DB
		if(!db.open(this->counterPath, HashDB::OREADER | HashDB::OCREATE))
			throw "Cannot open DB";
		db.get("user_counter", &counter_value);
		// close connection to DB
		if (!db.close())
			throw "Cannot close DB";
		
	} catch (string e){
		// find way to store it to log file
		// C-err for now
		cerr << e << endl;
	}
	
	// create new user object
	int newUserId = std::stoi(counter_value);
	User newUser;
	newUser.id = newUserId;
	newUser.isMale = profile.isMale;
	newUser.birthDate = profile.birthDate;
	newUser.name = profile.name;
	newUser.phoneNumber = profile.phoneNumber;
	newUser.lastActive = 0;
	
	// write to memory buffer
	newUser.write(oprot_.get());
		
	// Store to file system DB
	try {
		// open DB
		if(!db.open(this->dbPath, HashDB::OWRITER | HashDB::OCREATE))
			throw "Cannot open DB";
		
		// store record with key: user id - value: user data
		if(!db.set(to_string(newUserId), buffer_->getBufferAsString()))
			throw "Cannot store file to DB";
		
		// close connection to DB
		if (!db.close())
			throw "Cannot close DB";
		
		// update counter
		// open DB
		if(!db.open(this->counterPath, HashDB::OWRITER | HashDB::OCREATE))
			throw "Cannot open DB";
		
		// store record with key: user id - value: user data
		if(!db.set("user_counter", to_string(++newUserId)))
			throw "Cannot update counter to DB";
		
		// close connection to DB
		if (!db.close())
			throw "Cannot close DB";
		
	} catch (string e){
		// find way to store it to log file
		// C-err for now
		cerr << e << endl;
	}
	
	// return user id
	return newUser.id;
}

void FriendServicesHandler::GetUserInformation(GetUserResult& _return, const int32_t id){
	string value = "";
	try {
		// open connection to DB
		if (!db.open(this->dbPath, HashDB::OREADER | HashDB::OCREATE))
			throw "Cannot open DB";
		
		// Retrieve user data from DB
		using apache::thrift::to_string;
		db.get(to_string(id), &value);
		
		// close connection to DB
		if (!db.close())
			throw "Cannot close DB";
	} catch (string e){
		cerr << e << endl;
		_return.__isset.data = false;
		_return.code = ErrorCode::INTERNAL_ERROR;
		return;
	}
	
	if (value == ""){ // can not find user data
		_return.__isset.data = false;
		_return.code = ErrorCode::USER_NOT_FOUND;
		return;
	}
	
	// value is user data as string -> convert back to data
	// this will discard any existed data in buffer_ and construct new one
	// with data from DB string.
	buffer_->resetBuffer((uint8_t*)value.data(), static_cast<uint32_t>(value.length()));
	_return.__isset.data = true;
	_return.data.read(iprot_.get());
	_return.code = ErrorCode::SUCCESS;
	
	return;
}

void FriendServicesHandler::checkRequest(pingResult& _return, const int32_t id){
	string value = "";
	try {
		if (!db.open(this->pendingPath, HashDB::OREADER | HashDB::OCREATE))
			throw "Cannot open database";
		using apache::thrift::to_string;
		db.get(to_string(id), &value);
		if (!db.close())
			throw "Cannot close database";
	} catch (string e){
		cerr << e << endl;
		_return.__isset.haveData = false;
		return;
	}
	
	_return.haveData = value != "";
	if (_return.haveData){
		// de-serialize string from DB
//		buffer_.get()->resetBuffer((uint8_t*)value.data(), static_cast<uint32_t>(value.length()));
//		User data;
//		data.read(iprot_.get());
//		
//		if (!data.pendingRequest.empty())
//			_return.__set_pendingData(data.pendingRequest);
//		else
//			_return.__set_haveData(false);
//		return;
		std::set<int32_t> data(value.begin(), value.end());
		if (!data.empty())
			_return.__set_pendingData(data);
		else
			_return.__set_haveData(false);
		return;
	}
	return;
}

void FriendServicesHandler::dispatchAddFriend(const int32_t curId, const int32_t friendId){
	string value = "";
	try {
		if (!db.open(this->pendingPath, HashDB::OWRITER | HashDB::OCREATE))
			throw "Cannot open database";
		
		// put curId into friend's pending list
		db.get(to_string(friendId), &value);
		std::set<int32_t> data(value.begin(), value.end());
		data.insert(curId);
		db.set(to_string(friendId), to_string(data));
		
		if (!db.close())
			throw "Cannot close database";
	} catch (string e){
		cerr << e << endl;
	}
}

ErrorCode::type FriendServicesHandler::addFriend(const int32_t curId, const int32_t friendId){
	// check for exist id
	try {
		if (!db.open(this->dbPath, HashDB::OREADER))
			throw "Cannot open database";
		
		using apache::thrift::to_string;
		if (db.check(to_string(curId)) < 0 || db.check(to_string(friendId)) < 0)
			return ErrorCode::USER_NOT_FOUND;
		
		if (!db.close())
			throw "Cannot close database";
	} catch (string e){
		cerr << e << endl;
		return ErrorCode::INTERNAL_ERROR;
	}
	
	// create new thread to add friend id to pending and then return
	AddFriendRunnable runnable(curId, friendId, this);	
	Poco::Thread newThread;
	newThread.start(runnable);
	
	// skip I/O run-time
	return ErrorCode::SUCCESS;
}
